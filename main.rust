// src/main.rs
mod sensor;
mod error;
use std::io;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;
use clap::Parser;
use embedded_hal_mock::eh0::i2c::{Mock as I2cMock, Transaction as I2cTransaction};
use sensor::{TemperatureSensor, Resolution};
use crate::error::SensorError;
use rand::Rng;
use env_logger::Builder; 
use log::LevelFilter;  
сенсор (симуляція)
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(short, long, default_value_t = 2)]
    delay: u64,

    #[arg(short, long, default_value_t = 72)]
    address: u8,
}
fn main() {
    let args = Args::parse();
    Builder::new()
        .filter_level(LevelFilter::Info) 
        .init();
    log::info!("Запуск моніторингу. Натисніть Ctrl+C для завершення.");
    log::info!("Інтервал: {} с, Адреса сенсора: 0x{:02X} ({})", args.delay, args.address, args.address);
    let running = Arc::new(AtomicBool::new(true));
    let r = running.clone();
    ctrlc::set_handler(move || {
        r.store(false, Ordering::SeqCst);
    }).expect("Помилка встановлення обробника Ctrl-C");
    let mut min_temp = f32::MAX;
    let mut max_temp = f32::MIN;
    let mut temp_sum = 0.0;
    let mut successful_readings = 0;
    while running.load(Ordering::SeqCst) {
        let config_transaction = I2cTransaction::write(args.address, vec![0x01, 0b10]); 
        let mut rng = rand::thread_rng();
        let temp_c: f32 = rng.gen_range(35.0..55.0);
        let raw_val = (temp_c * 256.0) as i16;
        let bytes = raw_val.to_be_bytes();
        let read_transaction = I2cTransaction::write_read(args.address, vec![0x00], vec![bytes[0], bytes[1]]);
        let expectations = [config_transaction, read_transaction];
        let i2c_mock = I2cMock::new(&expectations);
        let mut sensor = match TemperatureSensor::new(i2c_mock, args.address, Resolution::High) {
            Ok(s) => s,
            Err(_) => {
                log::error!("Помилка симуляції під час ініціалізації.");
                break;
            }
        };
        match sensor.read_temperature() {
            Ok(temp) => {
                println!("Поточна температура: {:.2}°C", temp);
                min_temp = min_temp.min(temp);
                max_temp = max_temp.max(temp);
                temp_sum += temp;
                successful_readings += 1;
            }
            Err(SensorError::InvalidData) => log::error!("Помилка: отримано невалідні дані з сенсора."),
            Err(SensorError::I2c(_)) => {
                log::error!("Критична помилка шини I2C. Перевірте підключення.");
                break;
            }
        }
        let mut i2c_mock = sensor.release();
        i2c_mock.done();
        for _ in 0..args.delay {
            if !running.load(Ordering::SeqCst) {
                break;
            }
            thread::sleep(Duration::from_secs(1));
        }
    }
    println!("\n--- Підсумковий звіт ---");
    if successful_readings > 0 {
        println!("Всього успішних зчитувань: {}", successful_readings);
        println!("Мінімальна температура: {:.2}°C", min_temp);
        println!("Максимальна температура: {:.2}°C", max_temp);
        println!("Середня температура:    {:.2}°C", temp_sum / successful_readings as f32);
    } else {
        println!("Не було отримано жодного валідного значення температури.");
    }
    println!("--------------------------\n");
    println!("Натисніть клавішу Enter, щоб закрити програму...");
    let mut buffer = String::new();
    io::stdin().read_line(&mut buffer).expect("Не вдалося прочитати рядок");
    log::info!("Програма завершила роботу.");
}
sensor.rs:
// src/sensor.rs
use embedded_hal::blocking::i2c::{Write, Read, WriteRead};
use crate::error::SensorError;
use log::{info, warn};
const REG_TEMP: u8 = 0x00;       
const REG_CONFIG: u8 = 0x01;     
#[allow(dead_code)]
pub enum Resolution {
    Low,    // 0b00
    Medium, // 0b01
    High,   // 0b10
}
pub struct TemperatureSensor<I2C> {
    i2c: I2C,
    address: u8,
}
impl<I2C, E> TemperatureSensor<I2C>
where
    I2C: Write<Error = E> + Read<Error = E> + WriteRead<Error = E>,
{
    pub fn new(mut i2c: I2C, address: u8, resolution: Resolution) -> Result<Self, SensorError<E>> {
        info!("Ініціалізація сенсора за адресою 0x{:02X}", address);
        let config_byte = match resolution {
            Resolution::Low => 0b00,
            Resolution::Medium => 0b01,
            Resolution::High => 0b10,
        };
        i2c.write(address, &[REG_CONFIG, config_byte])?;
        info!("Конфігурацію (роздільна здатність) записано: 0b{:02b}", config_byte);
        Ok(TemperatureSensor { i2c, address })
    }
    pub fn read_temperature(&mut self) -> Result<f32, SensorError<E>> {
        let mut buffer = [0u8; 2];
        self.i2c.write_read(self.address, &[REG_TEMP], &mut buffer)?;
        let raw_temp = i16::from_be_bytes(buffer); 
        const ERROR_VALUE: i16 = i16::MIN; 
        if raw_temp == ERROR_VALUE {
            warn!("Сенсор повернув значення помилки! [0x{:04X}]", raw_temp as u16);
            return Err(SensorError::InvalidData);
        }
        let temperature = raw_temp as f32 / 256.0;
        info!("Зчитано сирі дані: [0x{:02X}, 0x{:02X}], температура: {:.2}°C", buffer[0], buffer[1], temperature);
        Ok(temperature)
    }
    pub fn release(self) -> I2C {
        self.i2c
    }
}
